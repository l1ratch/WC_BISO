### Подробное объяснение логики выполнения заданий и ответы на вопросы

---

#### **Задание 1: Создание локальной временной таблицы**
**Логика команды:**
1. Временная таблица создаётся с помощью `CREATE TEMP TABLE`, она существует только в рамках текущей сессии.
2. Чётные записи выбираются с помощью фильтрации: `WHERE order_id % 2 = 0`. Это проверяет остаток от деления `order_id` на 2, равный 0.

**Объяснение:**
- Временные таблицы полезны для выполнения промежуточных вычислений, чтобы не изменять оригинальные данные.
- Временные таблицы исчезают после завершения сессии, что обеспечивает безопасность данных.

**Типичные вопросы:**
1. **Почему не выбираются нечётные записи?**
   - Это требование задания. Логика фильтрации может быть изменена при необходимости.
2. **Можно ли добавить индекс в временную таблицу?**
   - Да, индексы можно добавлять, но они тоже будут временными.

---

#### **Задание 2: Добавление записи в временную таблицу**
**Логика команды:**
- Используется команда `INSERT INTO`, которая добавляет строку в таблицу. Поля и их значения перечисляются в том же порядке, что и в структуре таблицы.

**Объяснение:**
- Временные таблицы не требуют ссылочной целостности или внешних ключей, что делает добавление записей быстрее.

**Типичные вопросы:**
1. **Можно ли использовать `DEFAULT` для некоторых столбцов?**
   - Да, если столбец имеет значение по умолчанию в оригинальной таблице.
2. **Можно ли добавить строку, нарушающую уникальность?**
   - Да, если временная таблица не имеет ограничений на уникальность.

---

#### **Задание 3: Ошибка доступа из другой сессии**
**Логика команды:**
- Ошибка возникает, потому что временные таблицы (`TEMP`) создаются только для текущей сессии и недоступны другим.

**Решение:**
- Чтобы таблица была доступна в других сессиях, используем `UNLOGGED TABLE`. Она сохраняется в базе данных, но не логируется, что ускоряет операции.

**Ответы на вопросы:**
1. **Почему временная таблица недоступна в других сессиях?**
   - Это ограничение PostgreSQL для изоляции данных временной таблицы.
2. **Почему используется `UNLOGGED`, а не обычная таблица?**
   - `UNLOGGED` таблицы быстрее, так как данные не записываются в журнал транзакций.

---

#### **Задание 4: Копирование таблицы и добавление столбца**
**Логика команды:**
1. Таблица копируется с использованием структуры оригинальной таблицы.
2. Добавляется столбец `log_date`, который будет использоваться для секционирования.

**Объяснение:**
- Секционирование позволяет PostgreSQL разделять данные на логические части, что ускоряет запросы и упрощает администрирование.

**Ответы на вопросы:**
1. **Почему `log_date` обязательно `NOT NULL`?**
   - Секционирование требует, чтобы столбец имел значения, иначе невозможно определить, в какую секцию вставить запись.
2. **Можно ли секционировать по нескольким столбцам?**
   - Да, но это усложнит структуру и выборку данных.

---

#### **Задание 5: Создание секции для диапазона дат**
**Логика команды:**
- Создаётся секция для диапазона дат с помощью `PARTITION OF`. Она хранит данные, относящиеся только к заданному диапазону.

**Ответы на вопросы:**
1. **Что произойдёт, если вставить запись за пределами диапазона?**
   - PostgreSQL выдаст ошибку, так как запись не соответствует ни одной секции.
2. **Можно ли автоматически создавать секции?**
   - Нет, секции нужно создавать вручную, но можно написать триггер для автоматизации.

---

#### **Задание 6: Оконная функция row_number()**
**Логика команды:**
1. Оконные функции вычисляются для каждой строки результата, без группировки.
2. `ROW_NUMBER()` присваивает уникальный номер каждой строке в порядке сортировки.

**Объяснение:**
- Оконные функции позволяют добавлять метаинформацию к результатам запроса (например, нумерацию строк).

**Ответы на вопросы:**
1. **Чем `ROW_NUMBER` отличается от `RANK`?**
   - `ROW_NUMBER` всегда присваивает уникальные номера строкам, а `RANK` может дублировать номера при одинаковых значениях.
2. **Можно ли использовать оконную функцию без ORDER BY?**
   - Нет, она требует порядка.

---

#### **Задание 7: Использование CTE**
**Логика команды:**
- CTE (`WITH`) создаёт временный результат, который используется в основном запросе.

**Объяснение:**
- Упрощает сложные запросы, делая их более читаемыми.

**Ответы на вопросы:**
1. **CTE быстрее подзапросов?**
   - Нет, CTE обрабатываются как подзапросы, но их легче читать и отлаживать.
2. **Можно ли использовать CTE для изменения данных?**
   - Да, с CTE можно выполнять `INSERT`, `UPDATE` или `DELETE`.

---

#### **Задание 8: Временная таблица с столбцом IDENTITY**
**Логика команды:**
- Столбец `IDENTITY` автоматически генерирует уникальные значения для каждой строки, начиная с 1.

**Объяснение:**
- Удобно для создания временных идентификаторов без ручного управления значениями.

**Ответы на вопросы:**
1. **Как управлять начальным значением IDENTITY?**
   - Используйте `START WITH` при создании столбца.
2. **Можно ли изменять значения IDENTITY?**
   - Нет, значения генерируются автоматически.

---

#### **Задание 9: Удаление записи и проверка IDENTITY**
**Логика команды:**
1. Запись с `idd = 1` удаляется.
2. PostgreSQL не позволяет вставить запись с `idd = 1`, так как IDENTITY генерирует последовательность автоматически.

**Ответы на вопросы:**
1. **Можно ли сбросить последовательность IDENTITY?**
   - Да, командой `ALTER SEQUENCE ... RESTART`.
2. **Почему нельзя явно задать IDENTITY?**
   - Это нарушает целостность данных, генерируемых системой. 

---

### Возможные вопросы:
1. **Как ускорить выборку из секционированной таблицы?**
   - Использовать индекс в секции и явно указывать диапазон в запросах.
2. **Что делать, если нужно удалить секцию?**
   - Удалить секцию можно командой `DROP TABLE`, но это не повлияет на другие секции.
3. **Почему `TEMP` таблицы исчезают при завершении сессии?**
   - Это стандартное поведение для изоляции данных временных операций.